# 数据解析和判断规则

## 概述

本文档详细分析 SP-API 返回的数据结构，以及系统如何从这些数据中提取变体信息、判断变体关系的规则和优先级。

## SP-API 响应数据结构

### 完整响应示例

```json
{
  "asin": "B08XYZ1234",
  "summaries": [
    {
      "brandName": "Example Brand",
      "parentAsin": "B08PARENT123",
      "browseClassification": {
        "displayName": "Electronics > Computers & Accessories"
      },
      "color": "Black",
      "itemName": "Example Product Name",
      "manufacturer": "Example Manufacturer",
      "modelNumber": "MODEL-123",
      "size": "Large",
      "style": "Modern",
      "websiteDisplayGroup": "electronics",
      "websiteDisplayGroupName": "Electronics"
    }
  ],
  "attributes": {
    "brand": ["Example Brand"],
    "color": ["Black"],
    "size": ["Large"],
    "model_number": ["MODEL-123"]
  },
  "relationships": [
    {
      "identifiers": {
        "marketplaceIdentifiers": [
          {
            "marketplaceId": "ATVPDKIKX0DER",
            "asin": "B08XYZ1234"
          }
        ]
      },
      "relationships": [
        {
          "type": "PARENT",
          "asin": "B08PARENT123"
        },
        {
          "type": "CHILD",
          "asin": "B08XYZ5678"
        }
      ]
    }
  ],
  "variations": [
    {
      "variationType": "PARENT",
      "asins": ["B08XYZ1234", "B08XYZ5678", "B08XYZ9012"],
      "relationships": [
        {
          "parentAsins": ["B08PARENT123"],
          "childAsins": ["B08XYZ1234", "B08XYZ5678", "B08XYZ9012"]
        }
      ]
    }
  ]
}
```

## 数据字段详解

### summaries 字段

#### summaries[0].parentAsin

**位置**：`result.summaries[0].parentAsin`

**类型**：`string | null`

**说明**：

- 如果当前 ASIN 是变体，这里会直接包含父体 ASIN
- 如果当前 ASIN 是父体或独立商品，这里为 `null`
- 这是最直接、最可靠的父体 ASIN 来源

**提取代码**：

```121:122:backend/services/variantMonitor.js
    // 旧结构：summaries.parentAsin
    parentAsin = result?.summaries?.[0]?.parentAsin || null;
```

#### summaries[0].brandName

**位置**：`result.summaries[0].brandName`

**类型**：`string | null`

**说明**：

- 商品的品牌名称
- 通常是最准确的品牌信息
- 优先于 attributes.brand 使用

**提取代码**：

```113:119:backend/services/variantMonitor.js
    // 品牌：优先 summaries.brandName，其次 attributes.brand
    brand =
      result?.summaries?.[0]?.brandName ??
      (Array.isArray(result?.attributes?.brand)
        ? result.attributes.brand[0]
        : result?.attributes?.brand) ??
      null;
```

### attributes 字段

#### attributes.brand

**位置**：`result.attributes.brand`

**类型**：`string | string[] | null`

**说明**：

- 品牌信息，可能是字符串或字符串数组
- 如果为数组，通常取第一个元素
- 作为 brandName 的备选方案

**处理逻辑**：

```javascript
// 如果是数组，取第一个元素
Array.isArray(result?.attributes?.brand)
  ? result.attributes.brand[0]
  : result?.attributes?.brand;
```

### relationships 字段

#### relationships[*].relationships[*]

**位置**：`result.relationships[].relationships[]`

**类型**：`Array<{ type: string, asin: string }>`

**说明**：

- 嵌套的关系结构（旧版本 API）
- 包含类型为"PARENT"的关系对象
- 需要遍历查找

**提取代码**：

```124:134:backend/services/variantMonitor.js
    // 旧结构：relationships[*].relationships[*].type === 'PARENT' && asin
    if (!parentAsin && Array.isArray(result?.relationships)) {
      for (const rel of result.relationships) {
        const arr = Array.isArray(rel?.relationships) ? rel.relationships : [];
        const p = arr.find(x => String(x?.type).toUpperCase() === 'PARENT' && x?.asin);
        if (p?.asin) {
          parentAsin = p.asin;
          break;
        }
      }
    }
```

**查找条件**：

- `type` 字段（转换为大写）等于 "PARENT"
- 存在 `asin` 字段

### variations 字段

#### variations[0].asins

**位置**：`result.variations[0].asins`

**类型**：`string[]`

**说明**：

- 包含所有变体 ASIN 的数组
- **包括自身 ASIN**
- 用于识别兄弟 ASIN

**提取代码**：

```106:111:backend/services/variantMonitor.js
    // 旧结构：variation.asins 里是兄弟 asin
    const asinsList = Array.isArray(variations?.[0]?.asins) ? variations[0].asins : [];
    brotherAsins = asinsList
      .map(x => String(x || '').toUpperCase())
      .filter(a => a && a !== asinNorm);
    hasVariation = brotherAsins.length > 0;
```

**处理步骤**：

1. 获取 `variations[0].asins` 数组
2. 转换为大写并标准化
3. **过滤自身**：排除当前查询的 ASIN
4. 剩余 ASIN 即为兄弟 ASIN

#### variations[*].relationships[*].parentAsins

**位置**：`result.variations[].relationships[].parentAsins`

**类型**：`string[]`

**说明**：

- 新版本 API 中的父体 ASIN 数组
- 通常取第一个元素
- 作为父体 ASIN 的备选来源

**提取代码**：

```136:148:backend/services/variantMonitor.js
    // ⭐ 新结构：variations[*].relationships[*].parentAsins[0]
    if (!parentAsin && Array.isArray(variations)) {
      for (const v of variations) {
        const rels = Array.isArray(v?.relationships) ? v.relationships : [];
        for (const r of rels) {
          if (Array.isArray(r?.parentAsins) && r.parentAsins.length) {
            parentAsin = r.parentAsins[0];
            break;
          }
        }
        if (parentAsin) break;
      }
    }
```

**查找条件**：

- `parentAsins` 是数组
- 数组长度大于 0
- 取第一个元素作为父体 ASIN

## 数据格式兼容处理

### 新旧格式兼容

系统需要兼容不同版本的 API 响应格式：

#### 旧格式（Legacy）

```json
{
  "relationships": [
    {
      "relationships": [
        {
          "type": "PARENT",
          "asin": "B08PARENT123"
        }
      ]
    }
  ]
}
```

#### 新格式（Current）

```json
{
  "summaries": [
    {
      "parentAsin": "B08PARENT123"
    }
  ],
  "variations": [
    {
      "relationships": [
        {
          "parentAsins": ["B08PARENT123"]
        }
      ]
    }
  ]
}
```

### 兼容处理策略

系统采用**优先级策略**来处理不同格式：

1. **第一优先级**：`summaries[0].parentAsin`（新格式，最直接）
2. **第二优先级**：`relationships[].relationships[]`（旧格式，嵌套结构）
3. **第三优先级**：`variations[].relationships[].parentAsins[]`（新格式，数组形式）

**代码实现**：

```121:148:backend/services/variantMonitor.js
    // 旧结构：summaries.parentAsin
    parentAsin = result?.summaries?.[0]?.parentAsin || null;

    // 旧结构：relationships[*].relationships[*].type === 'PARENT' && asin
    if (!parentAsin && Array.isArray(result?.relationships)) {
      for (const rel of result.relationships) {
        const arr = Array.isArray(rel?.relationships) ? rel.relationships : [];
        const p = arr.find(x => String(x?.type).toUpperCase() === 'PARENT' && x?.asin);
        if (p?.asin) {
          parentAsin = p.asin;
          break;
        }
      }
    }

    // ⭐ 新结构：variations[*].relationships[*].parentAsins[0]
    if (!parentAsin && Array.isArray(variations)) {
      for (const v of variations) {
        const rels = Array.isArray(v?.relationships) ? v.relationships : [];
        for (const r of rels) {
          if (Array.isArray(r?.parentAsins) && r.parentAsins.length) {
            parentAsin = r.parentAsins[0];
            break;
          }
        }
        if (parentAsin) break;
      }
    }
```

**设计原则**：

- 按优先级顺序尝试
- 找到后立即停止（使用 `break`）
- 确保只使用第一个找到的父体 ASIN

## 判断规则详解

### 规则 1：兄弟 ASIN 判断

**判断条件**：

```javascript
hasVariation = brotherAsins.length > 0;
```

**逻辑说明**：

- 如果 `brotherAsins` 数组长度大于 0，说明存在其他变体
- 此时 `hasVariation = true`

**注意事项**：

- `brotherAsins` 已经过滤了自身 ASIN
- 如果只有自身，`brotherAsins` 为空数组，`hasVariation = false`

### 规则 2：父体 ASIN 判断

**判断条件**：

```168:171:backend/services/variantMonitor.js
  // 3) 只要拿到父体，就认为存在变体（哪怕没有兄弟 asins）
  if (parentAsin && !hasVariation) {
    hasVariation = true;
  }
```

**逻辑说明**：

- 如果存在父体 ASIN（`parentAsin` 不为 null）
- 且当前 `hasVariation` 为 `false`
- 则设置 `hasVariation = true`

**设计理由**：

- 父体 ASIN 的存在表明该 ASIN 属于某个变体组
- 即使没有兄弟 ASIN（可能其他变体已下架），仍应认为有变体关系
- 更符合业务逻辑

### 规则 3：最终判断优先级

**完整判断流程**：

```
1. 初始化：hasVariation = false

2. 提取兄弟ASIN：
   - 如果有兄弟ASIN → hasVariation = true
   - 否则保持 false

3. 提取父体ASIN：
   - 如果找到父体ASIN → hasVariation = true（即使之前为false）

4. 最终结果：
   - 有兄弟ASIN OR 有父体ASIN → hasVariation = true
   - 都没有 → hasVariation = false
```

**代码实现**：

```106:171:backend/services/variantMonitor.js
    // 旧结构：variation.asins 里是兄弟 asin
    const asinsList = Array.isArray(variations?.[0]?.asins) ? variations[0].asins : [];
    brotherAsins = asinsList
      .map(x => String(x || '').toUpperCase())
      .filter(a => a && a !== asinNorm);
    hasVariation = brotherAsins.length > 0;

    // ... 品牌提取 ...

    // ... 父体ASIN提取 ...

  // 3) 只要拿到父体，就认为存在变体（哪怕没有兄弟 asins）
  if (parentAsin && !hasVariation) {
    hasVariation = true;
  }
```

## 数据标准化

### ASIN 标准化

**规则**：

- 转换为大写
- 去除首尾空格
- 统一格式

**代码**：

```87:87:backend/services/variantMonitor.js
  const asinNorm = String(asin || '').trim().toUpperCase();
```

**应用场景**：

- 输入 ASIN 标准化
- 兄弟 ASIN 标准化
- 父体 ASIN 标准化

### 品牌标准化

**规则**：

- 如果为 `null` 或 `undefined`，转换为 "未知"
- 保持原始值（不转换大小写）

**代码**：

```177:177:backend/services/variantMonitor.js
    brand: brand ?? '未知',
```

### 父体 ASIN 标准化

**规则**：

- 如果存在，转换为大写
- 如果不存在，保持 `null`

**代码**：

```178:178:backend/services/variantMonitor.js
    parentAsin: parentAsin ? String(parentAsin).toUpperCase() : null,
```

## 边界情况处理

### 情况 1：variations 为空但 relationships 有数据

**处理方式**：

```102:104:backend/services/variantMonitor.js
    const relationships = Array.isArray(result?.relationships) ? result.relationships : [];
    const variationsField = Array.isArray(result?.variations) ? result.variations : [];
    variations = variationsField.length ? variationsField : relationships;
```

**说明**：

- 优先使用 `variations`
- 如果 `variations` 为空，回退到 `relationships`
- 确保后续处理有数据可用

### 情况 2：parentAsins 数组为空

**处理方式**：

```141:141:backend/services/variantMonitor.js
          if (Array.isArray(r?.parentAsins) && r.parentAsins.length) {
```

**说明**：

- 检查数组是否存在
- 检查数组长度是否大于 0
- 只有满足条件才提取父体 ASIN

### 情况 3：attributes.brand 为数组或字符串

**处理方式**：

```116:118:backend/services/variantMonitor.js
      (Array.isArray(result?.attributes?.brand)
        ? result.attributes.brand[0]
        : result?.attributes?.brand) ??
```

**说明**：

- 如果是数组，取第一个元素
- 如果是字符串，直接使用
- 使用空值合并操作符处理 null/undefined

### 情况 4：type 字段大小写不一致

**处理方式**：

```128:128:backend/services/variantMonitor.js
        const p = arr.find(x => String(x?.type).toUpperCase() === 'PARENT' && x?.asin);
```

**说明**：

- 将 `type` 字段转换为大写后比较
- 确保不区分大小写
- 兼容不同 API 版本的大小写差异

## 数据验证

### 数组安全检查

系统使用多种方式确保数组访问安全：

1. **可选链操作符**：`result?.variations`
2. **Array.isArray()检查**：`Array.isArray(result?.variations)`
3. **数组长度检查**：`variations.length > 0`
4. **数组元素存在检查**：`variations[0]?.asins`

### 空值处理

使用空值合并操作符 `??` 和逻辑或 `||` 处理空值：

```javascript
// 使用 ?? 处理 null/undefined
brand = result?.summaries?.[0]?.brandName ?? null;

// 使用 || 处理 falsy 值
parentAsin = result?.summaries?.[0]?.parentAsin || null;
```

## 性能优化

### 提前退出

在多层循环中使用 `break` 提前退出：

```136:148:backend/services/variantMonitor.js
    // ⭐ 新结构：variations[*].relationships[*].parentAsins[0]
    if (!parentAsin && Array.isArray(variations)) {
      for (const v of variations) {
        const rels = Array.isArray(v?.relationships) ? v.relationships : [];
        for (const r of rels) {
          if (Array.isArray(r?.parentAsins) && r.parentAsins.length) {
            parentAsin = r.parentAsins[0];
            break;  // 内层循环退出
          }
        }
        if (parentAsin) break;  // 外层循环退出
      }
    }
```

**优化效果**：

- 找到父体 ASIN 后立即停止搜索
- 减少不必要的循环迭代
- 提高处理效率

### 条件检查顺序

按照优先级顺序检查，找到后立即停止：

```121:148:backend/services/variantMonitor.js
    // 旧结构：summaries.parentAsin
    parentAsin = result?.summaries?.[0]?.parentAsin || null;

    // 旧结构：relationships[*].relationships[*].type === 'PARENT' && asin
    if (!parentAsin && Array.isArray(result?.relationships)) {
      // ... 只在 parentAsin 为空时执行
    }

    // ⭐ 新结构：variations[*].relationships[*].parentAsins[0]
    if (!parentAsin && Array.isArray(variations)) {
      // ... 只在 parentAsin 为空时执行
    }
```

**优化效果**：

- 优先使用最直接的数据源
- 避免不必要的复杂查找
- 提高整体性能

## 总结

数据解析和判断规则的设计充分考虑了：

1. **兼容性**：支持新旧 API 格式
2. **健壮性**：完善的空值和数组检查
3. **性能**：提前退出和优先级策略
4. **准确性**：多层验证确保数据正确性

这些规则确保了系统能够从各种格式的 API 响应中准确提取变体信息。
