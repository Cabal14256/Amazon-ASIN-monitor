# 变体查询核心逻辑详解

## 概述

`getVariantData()` 函数是整个 ASIN 变体查询系统的核心，它负责从 Amazon SP-API 获取商品信息，并从中提取变体关系、父体 ASIN 和品牌信息。

## 函数签名

```86:86:backend/services/variantMonitor.js
async function getVariantData(asin, marketKey) {
```

**参数**：

- `asin`: 要查询的 ASIN 码（字符串）
- `marketKey`: 市场代码（'US' | 'UK' | 'DE' | 'FR' | 'IT' | 'ES'）

**返回值**：

```typescript
{
  variations: Array,      // 变体信息数组
  brotherAsins: Array,    // 兄弟ASIN列表
  hasVariation: boolean,  // 是否有变体
  brand: string,         // 品牌名称
  parentAsin: string | null  // 父体ASIN
}
```

## 完整函数解析

### 第一步：初始化变量

```87:93:backend/services/variantMonitor.js
  const asinNorm = String(asin || '').trim().toUpperCase();

  let variations = [];
  let brotherAsins = [];
  let hasVariation = false;
  let brand = null;
  let parentAsin = null;
```

**关键操作**：

- **ASIN 标准化**：转换为大写并去除空格，确保一致性
- **初始化状态变量**：所有变量初始化为"无变体"状态

### 第二步：调用 SP-API 获取商品信息

```95:100:backend/services/variantMonitor.js
  // 1) 官方 SP-API 调 catalogItems v2022-04-01
  try {
    const sp = makeSp(marketKey);                                // 按 US/EU 取凭据
    const marketplaceId = MARKETPLACE[marketKey] || MARKETPLACE.US;

    const result = await getCatalogItem(sp, asinNorm, marketplaceId);
```

**流程说明**：

1. 根据市场代码创建 SP-API 客户端（自动选择 US 或 EU 区域）
2. 获取对应的 Marketplace ID（如果市场代码无效，默认使用 US）
3. 调用 Catalog Items API 获取商品信息

### 第三步：提取变体信息

#### 3.1 获取变体数组

```102:104:backend/services/variantMonitor.js
    const relationships = Array.isArray(result?.relationships) ? result.relationships : [];
    const variationsField = Array.isArray(result?.variations) ? result.variations : [];
    variations = variationsField.length ? variationsField : relationships;
```

**逻辑说明**：

- 优先使用 `variations` 字段（新结构）
- 如果 `variations` 为空，回退到 `relationships` 字段（旧结构）
- 使用可选链操作符 `?.` 和 `Array.isArray()` 确保安全访问

#### 3.2 提取兄弟 ASIN

```106:111:backend/services/variantMonitor.js
    // 旧结构：variation.asins 里是兄弟 asin
    const asinsList = Array.isArray(variations?.[0]?.asins) ? variations[0].asins : [];
    brotherAsins = asinsList
      .map(x => String(x || '').toUpperCase())
      .filter(a => a && a !== asinNorm);
    hasVariation = brotherAsins.length > 0;
```

**处理步骤**：

1. 从 `variations[0].asins` 获取 ASIN 列表
2. 转换为大写并标准化
3. **过滤自身**：排除当前查询的 ASIN
4. **判断变体**：如果有兄弟 ASIN，则认为存在变体

**关键点**：

- 兄弟 ASIN 列表包含所有变体，包括自身
- 通过过滤自身来判断是否有其他变体

### 第四步：提取品牌信息

```113:119:backend/services/variantMonitor.js
    // 品牌：优先 summaries.brandName，其次 attributes.brand
    brand =
      result?.summaries?.[0]?.brandName ??
      (Array.isArray(result?.attributes?.brand)
        ? result.attributes.brand[0]
        : result?.attributes?.brand) ??
      null;
```

**优先级策略**：

1. **第一优先级**：`summaries[0].brandName`（最直接）
2. **第二优先级**：`attributes.brand[0]`（如果是数组，取第一个）
3. **第三优先级**：`attributes.brand`（如果不是数组，直接使用）
4. **默认值**：`null`（后续会转换为"未知"）

**使用空值合并操作符**：`??` 确保只在值为 `null` 或 `undefined` 时才使用下一个选项

### 第五步：提取父体 ASIN（多层策略）

系统采用多层策略来查找父体 ASIN，确保兼容不同版本的 API 响应。

#### 5.1 策略一：从 summaries 获取（最直接）

```121:122:backend/services/variantMonitor.js
    // 旧结构：summaries.parentAsin
    parentAsin = result?.summaries?.[0]?.parentAsin || null;
```

**说明**：这是最直接的方式，如果 ASIN 是变体，`summaries[0].parentAsin` 会直接包含父体 ASIN。

#### 5.2 策略二：从 relationships 嵌套结构获取（旧结构）

```124:134:backend/services/variantMonitor.js
    // 旧结构：relationships[*].relationships[*].type === 'PARENT' && asin
    if (!parentAsin && Array.isArray(result?.relationships)) {
      for (const rel of result.relationships) {
        const arr = Array.isArray(rel?.relationships) ? rel.relationships : [];
        const p = arr.find(x => String(x?.type).toUpperCase() === 'PARENT' && x?.asin);
        if (p?.asin) {
          parentAsin = p.asin;
          break;
        }
      }
    }
```

**查找逻辑**：

1. 遍历 `relationships` 数组
2. 在每个元素的 `relationships` 子数组中查找
3. 查找 `type === 'PARENT'` 且包含 `asin` 字段的对象
4. 找到后立即退出循环

**为什么需要这个策略**：

- 旧版本 API 可能将父体关系放在嵌套结构中
- 确保向后兼容

#### 5.3 策略三：从 variations.relationships 获取（新结构）

```136:148:backend/services/variantMonitor.js
    // ⭐ 新结构：variations[*].relationships[*].parentAsins[0]
    if (!parentAsin && Array.isArray(variations)) {
      for (const v of variations) {
        const rels = Array.isArray(v?.relationships) ? v.relationships : [];
        for (const r of rels) {
          if (Array.isArray(r?.parentAsins) && r.parentAsins.length) {
            parentAsin = r.parentAsins[0];
            break;
          }
        }
        if (parentAsin) break;
      }
    }
```

**查找逻辑**：

1. 遍历 `variations` 数组
2. 在每个变体的 `relationships` 数组中查找
3. 查找包含 `parentAsins` 数组且不为空的对象
4. 取 `parentAsins[0]` 作为父体 ASIN
5. 找到后立即退出所有循环

**为什么需要这个策略**：

- 新版本 API 将父体 ASIN 放在 `variations[].relationships[].parentAsins[]` 中
- 这是一个数组，通常取第一个元素

**多层循环退出**：

- 使用 `if (parentAsin) break;` 在外层循环中检查，确保找到后立即退出

### 第六步：错误处理

```150:152:backend/services/variantMonitor.js
  } catch (e) {
    console.error(`❌ 获取 ASIN ${asinNorm} @ ${marketKey} 失败:`, e?.message || e);
  }
```

**错误处理策略**：

- 捕获所有异常但不中断流程
- 记录错误日志（包含 ASIN 和市场代码）
- 继续执行兜底逻辑

**为什么不在这一步抛出异常**：

- 系统设计了多层兜底机制
- 即使 SP-API 失败，仍可通过其他方式获取信息

### 第七步：Legacy 客户端兜底

```154:166:backend/services/variantMonitor.js
  // 2) 如果官方 SP-API 还没给出父体，再用 legacySpClient 兜底
  if (!parentAsin && legacySpClient && typeof legacySpClient.getParentAndStatus === 'function') {
    try {
      const r = await legacySpClient.getParentAndStatus(asinNorm, marketKey);
      const raw = r?.parent_asin ?? r?.parentAsin ?? r?.parent ?? null;
      if (raw) parentAsin = String(raw).toUpperCase();
      if (typeof r?.is_broken === 'number') {
        hasVariation = r.is_broken === 0;
      }
    } catch (e) {
      console.warn('[VARIANT-MONITOR] legacy spClient failed:', e?.message || e);
    }
  }
```

**触发条件**：

- SP-API 未返回父体 ASIN（`!parentAsin`）
- Legacy 客户端可用（`legacySpClient` 存在）
- Legacy 客户端有 `getParentAndStatus` 方法

**处理逻辑**：

1. 调用 Legacy 客户端的 `getParentAndStatus()` 方法
2. 从返回结果中提取父体 ASIN（支持多种字段名）
3. 标准化父体 ASIN（转换为大写）
4. 如果返回了 `is_broken` 字段，更新 `hasVariation` 状态

**字段名兼容**：

- `parent_asin`（下划线命名）
- `parentAsin`（驼峰命名）
- `parent`（简化命名）

**为什么需要这个兜底**：

- Legacy 客户端可能使用不同的 API 版本或实现方式
- 提供额外的数据来源，提高查询成功率

### 第八步：最终判断逻辑

```168:171:backend/services/variantMonitor.js
  // 3) 只要拿到父体，就认为存在变体（哪怕没有兄弟 asins）
  if (parentAsin && !hasVariation) {
    hasVariation = true;
  }
```

**关键判断规则**：

- **有父体 ASIN = 有变体**：即使没有兄弟 ASIN，只要有父体 ASIN，就认为存在变体关系
- **为什么这样设计**：父体 ASIN 的存在本身就表明该 ASIN 是某个变体组的成员

**判断优先级**：

1. 如果有兄弟 ASIN → `hasVariation = true`（已在第三步设置）
2. 如果有父体 ASIN → `hasVariation = true`（这一步设置）
3. 都没有 → `hasVariation = false`（默认值）

### 第九步：返回结果

```173:179:backend/services/variantMonitor.js
  return {
    variations,
    brotherAsins,
    hasVariation,
    brand: brand ?? '未知',
    brand: brand ?? '未知',
    parentAsin: parentAsin ? String(parentAsin).toUpperCase() : null,
  };
}
```

**返回数据结构**：

- `variations`: 完整的变体信息数组（可用于进一步分析）
- `brotherAsins`: 兄弟 ASIN 列表（已过滤自身）
- `hasVariation`: 是否有变体的布尔值
- `brand`: 品牌名称（如果为 null 则返回"未知"）
- `parentAsin`: 父体 ASIN（如果存在则转换为大写，否则为 null）

**数据标准化**：

- 品牌：null → "未知"
- 父体 ASIN：存在时转换为大写，确保一致性

## 完整流程图

```
开始
  ↓
标准化ASIN（转大写）
  ↓
初始化变量（variations, brotherAsins, hasVariation, brand, parentAsin）
  ↓
┌─────────────────────────────────┐
│ 调用SP-API getCatalogItem()      │
└──────────────┬──────────────────┘
               │
        ┌──────▼──────┐
        │  成功？      │
        └──┬──────┬───┘
           │      │
         是│      │否
           │      │
    ┌──────▼──────┐
    │ 提取变体信息 │
    └──────┬──────┘
           │
    ┌──────▼──────────────────────────┐
    │ 1. 获取variations数组             │
    │ 2. 提取兄弟ASIN                   │
    │ 3. 提取品牌信息                   │
    │ 4. 多层策略查找父体ASIN：         │
    │    - summaries.parentAsin        │
    │    - relationships嵌套结构       │
    │    - variations.relationships     │
    └──────┬──────────────────────────┘
           │
    ┌──────▼──────────────────────────┐
    │ 是否有父体ASIN？                  │
    └──┬───────────────────────────────┘
       │
       │否
       │
┌──────▼──────────────────────────┐
│ 调用Legacy客户端兜底              │
│ - getParentAndStatus()          │
│ - 提取parent_asin/parentAsin    │
└──────┬──────────────────────────┘
       │
┌──────▼──────────────────────────┐
│ 最终判断：                        │
│ - 有兄弟ASIN → hasVariation=true │
│ - 有父体ASIN → hasVariation=true │
└──────┬───────────────────────────┘
       │
┌──────▼──────────────────────────┐
│ 返回结果                          │
│ {                                │
│   variations,                    │
│   brotherAsins,                  │
│   hasVariation,                  │
│   brand,                         │
│   parentAsin                     │
│ }                                │
└──────────────────────────────────┘
```

## 关键设计决策

### 1. 多层父体 ASIN 查找策略

**为什么需要多层策略**：

- Amazon API 在不同版本中返回的数据结构不同
- 确保向后兼容和向前兼容
- 提高查询成功率

**策略优先级**：

1. `summaries.parentAsin`（最直接，性能最好）
2. `relationships` 嵌套结构（旧版本兼容）
3. `variations.relationships.parentAsins`（新版本支持）

### 2. 兄弟 ASIN 过滤自身

**为什么过滤自身**：

- `variations[0].asins` 包含所有变体，包括自身
- 过滤后得到真正的"兄弟"ASIN
- 用于判断是否有其他变体

### 3. 父体 ASIN 存在即认为有变体

**设计理由**：

- 父体 ASIN 的存在表明该 ASIN 属于某个变体组
- 即使没有兄弟 ASIN（可能其他变体已下架），仍应认为有变体关系
- 更符合业务逻辑

### 4. 错误不中断流程

**设计理由**：

- 系统有兜底机制，即使 SP-API 失败仍可继续
- 提高系统容错性
- 避免单个 ASIN 查询失败影响整体流程

## 使用示例

### 示例 1：有变体的 ASIN

```javascript
const result = await getVariantData('B08XYZ1234', 'US');
// 返回：
// {
//   variations: [...],
//   brotherAsins: ['B08XYZ5678', 'B08XYZ9012'],
//   hasVariation: true,
//   brand: 'Brand Name',
//   parentAsin: 'B08PARENT123'
// }
```

### 示例 2：无变体的 ASIN

```javascript
const result = await getVariantData('B08SINGLE123', 'US');
// 返回：
// {
//   variations: [],
//   brotherAsins: [],
//   hasVariation: false,
//   brand: 'Brand Name',
//   parentAsin: null
// }
```

### 示例 3：SP-API 失败但 Legacy 成功

```javascript
// SP-API调用失败，但Legacy客户端成功获取父体
const result = await getVariantData('B08XYZ1234', 'US');
// 返回：
// {
//   variations: [],
//   brotherAsins: [],
//   hasVariation: true,  // Legacy客户端返回is_broken=0
//   brand: '未知',
//   parentAsin: 'B08PARENT123'  // 从Legacy客户端获取
// }
```

## 性能考虑

### 1. API 调用次数

- 每个 ASIN 调用一次 SP-API
- 如果 SP-API 失败，可能额外调用 Legacy 客户端
- 最坏情况：每个 ASIN 最多 2 次 API 调用

### 2. 数据处理

- 使用数组方法（map、filter、find）处理数据
- 多层循环但使用 break 提前退出
- 时间复杂度：O(n)，n 为变体数量

### 3. 内存使用

- 返回的数据结构较小
- 主要内存消耗在 API 响应解析

## 总结

`getVariantData()` 函数通过多层策略和兜底机制，确保了变体查询的高成功率。其设计充分考虑了 API 版本兼容性、错误处理和业务逻辑，是整个系统的核心组件。
