# 错误处理和兜底机制

## 概述

ASIN 变体查询系统采用三层兜底策略，确保即使在主要 API 调用失败的情况下，仍能尽可能获取变体信息。本文档详细分析错误处理机制和每层兜底的实现。

## 三层兜底架构

```
┌─────────────────────────────────────────┐
│  第一层：SP-API官方接口 (主要方式)        │
│  - getCatalogItem()                      │
│  - 成功率：~95%                          │
└──────────────┬──────────────────────────┘
                │ 失败
                ▼
┌─────────────────────────────────────────┐
│  第二层：Legacy SP-API客户端 (第一层兜底) │
│  - getParentAndStatus()                │
│  - 成功率：~80%                          │
└──────────────┬──────────────────────────┘
                │ 失败
                ▼
┌─────────────────────────────────────────┐
│  第三层：HTML页面抓取 (最后兜底)          │
│  - scrapeParentAsin()                  │
│  - 成功率：~60%                          │
└─────────────────────────────────────────┘
```

## 第一层：SP-API 官方接口

### 实现位置

```95:152:backend/services/variantMonitor.js
  // 1) 官方 SP-API 调 catalogItems v2022-04-01
  try {
    const sp = makeSp(marketKey);                                // 按 US/EU 取凭据
    const marketplaceId = MARKETPLACE[marketKey] || MARKETPLACE.US;

    const result = await getCatalogItem(sp, asinNorm, marketplaceId);

    const relationships = Array.isArray(result?.relationships) ? result.relationships : [];
    const variationsField = Array.isArray(result?.variations) ? result.variations : [];
    variations = variationsField.length ? variationsField : relationships;

    // 旧结构：variation.asins 里是兄弟 asin
    const asinsList = Array.isArray(variations?.[0]?.asins) ? variations[0].asins : [];
    brotherAsins = asinsList
      .map(x => String(x || '').toUpperCase())
      .filter(a => a && a !== asinNorm);
    hasVariation = brotherAsins.length > 0;

    // 品牌：优先 summaries.brandName，其次 attributes.brand
    brand =
      result?.summaries?.[0]?.brandName ??
      (Array.isArray(result?.attributes?.brand)
        ? result.attributes.brand[0]
        : result?.attributes?.brand) ??
      null;

    // 旧结构：summaries.parentAsin
    parentAsin = result?.summaries?.[0]?.parentAsin || null;

    // 旧结构：relationships[*].relationships[*].type === 'PARENT' && asin
    if (!parentAsin && Array.isArray(result?.relationships)) {
      for (const rel of result.relationships) {
        const arr = Array.isArray(rel?.relationships) ? rel.relationships : [];
        const p = arr.find(x => String(x?.type).toUpperCase() === 'PARENT' && x?.asin);
        if (p?.asin) {
          parentAsin = p.asin;
          break;
        }
      }
    }

    // ⭐ 新结构：variations[*].relationships[*].parentAsins[0]
    if (!parentAsin && Array.isArray(variations)) {
      for (const v of variations) {
        const rels = Array.isArray(v?.relationships) ? v.relationships : [];
        for (const r of rels) {
          if (Array.isArray(r?.parentAsins) && r.parentAsins.length) {
            parentAsin = r.parentAsins[0];
            break;
          }
        }
        if (parentAsin) break;
      }
    }

  } catch (e) {
    console.error(`❌ 获取 ASIN ${asinNorm} @ ${marketKey} 失败:`, e?.message || e);
  }
```

### 错误处理策略

**特点**：

- 使用 `try-catch` 包裹整个 API 调用
- 捕获异常但不中断流程
- 记录错误日志（包含 ASIN 和市场代码）
- 继续执行后续兜底逻辑

**错误日志格式**：

```
❌ 获取 ASIN B08XYZ1234 @ US 失败: [错误信息]
```

### 常见错误类型

#### 1. 400 InvalidInput

- **原因**：ASIN 格式错误、Marketplace ID 无效
- **处理**：记录错误，继续兜底
- **影响**：不影响后续流程

#### 2. 403 Unauthorized

- **原因**：凭据无效、令牌过期
- **处理**：记录错误，继续兜底
- **影响**：可能影响所有 ASIN 查询，需要检查凭据配置

#### 3. 404 NotFound

- **原因**：ASIN 不存在、商品不在指定市场
- **处理**：记录错误，继续兜底
- **影响**：单个 ASIN 查询失败，不影响其他 ASIN

#### 4. 429 TooManyRequests

- **原因**：超过 API 配额限制
- **处理**：记录错误，继续兜底
- **影响**：可能需要降低请求频率

#### 5. 500/503 服务器错误

- **原因**：Amazon 服务暂时不可用
- **处理**：记录错误，继续兜底
- **影响**：临时性错误，可重试

## 第二层：Legacy SP-API 客户端

### 触发条件

```154:166:backend/services/variantMonitor.js
  // 2) 如果官方 SP-API 还没给出父体，再用 legacySpClient 兜底
  if (!parentAsin && legacySpClient && typeof legacySpClient.getParentAndStatus === 'function') {
    try {
      const r = await legacySpClient.getParentAndStatus(asinNorm, marketKey);
      const raw = r?.parent_asin ?? r?.parentAsin ?? r?.parent ?? null;
      if (raw) parentAsin = String(raw).toUpperCase();
      if (typeof r?.is_broken === 'number') {
        hasVariation = r.is_broken === 0;
      }
    } catch (e) {
      console.warn('[VARIANT-MONITOR] legacy spClient failed:', e?.message || e);
    }
  }
```

**触发条件**：

1. 第一层未获取到父体 ASIN（`!parentAsin`）
2. Legacy 客户端可用（`legacySpClient` 存在）
3. Legacy 客户端有 `getParentAndStatus` 方法

### Legacy 客户端实现

#### getParentAndStatus 函数

```73:129:backend/utils/spClient.js
// 先 SP-API → 再 HTML 兜底
async function getParentAndStatus(asin, country='US') {
  const upper = String(asin).toUpperCase();
  let parent = null;

  try {
    const { sp, marketplaceId } = makeClient(country);

    const res = await sp.callAPI({
      endpoint:  'catalogItems',
      operation: 'getCatalogItem',
      path:      { asin: upper },
      query:     { marketplaceIds: [marketplaceId], includedData: ['summaries','variations','attributes'] }
    });

    // 1) summaries
    parent = res?.summaries?.[0]?.parentAsin || null;

    // 2) variations 兜底
    if (!parent && Array.isArray(res?.variations)) {
      for (const v of res.variations) {
        const vt = String(v?.variationType || v?.type || '').toUpperCase();
        if (vt === 'PARENT') {
          const idAsin =
            v?.identifiers?.find(i => i?.marketplaceId === marketplaceId)?.asin ||
            v?.identifiers?.[0]?.asin || null;
          if (idAsin) { parent = idAsin; break; }
        }
        if (!parent && Array.isArray(v?.relationships)) {
          const p = v.relationships.find(x => String(x?.type).toUpperCase() === 'PARENT' && x?.asin);
          if (p?.asin) { parent = p.asin; break; }
        }
        if (!parent && vt === 'PARENT' && v?.asin) { parent = v.asin; break; }
      }
    }

    // 3) 顶层 relationships（极少数）
    if (!parent && Array.isArray(res?.relationships)) {
      const p = res.relationships.find(x => String(x?.type).toUpperCase() === 'PARENT' && x?.asin);
      if (p?.asin) parent = p.asin;
    }

    parent = normalizeParent(parent, upper);

  } catch (e) {
    if (process.env.SP_DEBUG === '1') {
      console.warn('[SP] error:', e?.code || e?.name || '', e?.message || e);
    }
  }

  // 4) 如果 SP-API 还没拿到，就走 HTML 兜底
  if (!parent) {
    const scraped = await scrapeParentAsin(upper, country);
    parent = normalizeParent(scraped, upper);
  }

  return { parent_asin: parent, is_broken: parent ? 0 : 1 };
}
```

### Legacy 客户端的特点

#### 1. 使用不同的 API 调用方式

**官方 SP-API**：

```javascript
api_path: `/catalog/2022-04-01/items/${asin}`;
method: 'GET';
```

**Legacy 客户端**：

```javascript
endpoint: 'catalogItems';
operation: 'getCatalogItem';
path: {
  asin: upper;
}
```

**差异**：

- Legacy 使用 endpoint/operation 方式
- 可能使用不同版本的 API
- 提供额外的兼容性

#### 2. 额外的父体 ASIN 查找策略

Legacy 客户端实现了额外的查找策略：

**策略 1**：从 variations 中查找 type 为 PARENT 的变体

```javascript
if (vt === 'PARENT') {
  const idAsin = v?.identifiers?.find(i => i?.marketplaceId === marketplaceId)?.asin;
  if (idAsin) { parent = idAsin; break; }
}
```

**策略 2**：从 variations.relationships 中查找

```javascript
const p = v.relationships.find(
  (x) => String(x?.type).toUpperCase() === 'PARENT' && x?.asin,
);
```

**策略 3**：直接从 variation.asin 获取

```javascript
if (vt === 'PARENT' && v?.asin) { parent = v.asin; break; }
```

#### 3. 返回 is_broken 字段

Legacy 客户端返回 `is_broken` 字段：

- `0`: 有变体（正常）
- `1`: 无变体（异常）

**使用方式**：

```javascript
if (typeof r?.is_broken === 'number') {
  hasVariation = r.is_broken === 0;
}
```

### 字段名兼容处理

Legacy 客户端可能返回不同字段名的父体 ASIN：

```javascript
const raw = r?.parent_asin ?? r?.parentAsin ?? r?.parent ?? null;
```

**支持的字段名**：

- `parent_asin`（下划线命名）
- `parentAsin`（驼峰命名）
- `parent`（简化命名）

### 错误处理

```javascript
} catch (e) {
  console.warn('[VARIANT-MONITOR] legacy spClient failed:', e?.message || e);
}
```

**特点**：

- 使用 `console.warn` 而非 `console.error`（警告级别）
- 不中断流程，继续执行第三层兜底
- 记录错误信息

## 第三层：HTML 页面抓取

### 触发条件

在 Legacy 客户端内部，如果 SP-API 调用失败，会自动触发 HTML 抓取：

```122:126:backend/utils/spClient.js
  // 4) 如果 SP-API 还没拿到，就走 HTML 兜底
  if (!parent) {
    const scraped = await scrapeParentAsin(upper, country);
    parent = normalizeParent(scraped, upper);
  }
```

### HTML 抓取实现

#### scrapeParentAsin 函数

```18:44:backend/utils/spClient.js
// 兜底：HTML 抓取 parentAsin
async function scrapeParentAsin(asin, country='US') {
  const host = DOMAINS[country] || DOMAINS.US;
  const url = `https://${host}/dp/${String(asin).toUpperCase()}?psc=1`;
  try {
    const { data } = await axios.get(url, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125 Safari/537.36',
        'Accept-Language': 'en-US,en;q=0.9'
      },
      timeout: 15000,
      proxy: false,
    });

    const raw =
      data.match(/"parentAsin"\s*:\s*"([^"]+)"/i)?.[1] ||
      data.match(/"parent_asin"\s*:\s*"([^"]+)"/i)?.[1] ||
      data.match(/data-asin-parent="([^"]+)"/i)?.[1] ||
      data.match(/"twisterJsInit".*?"parentAsin"\s*:\s*"([^"]+)"/i)?.[1] ||
      data.match(/"variationDisplayData".*?"parentAsin"\s*:\s*"([^"]+)"/i)?.[1] ||
      null;

    return normalizeParent(raw, asin);
  } catch {
    return null;
  }
}
```

### HTML 抓取策略

#### 1. 构建 URL

```javascript
const host = DOMAINS[country] || DOMAINS.US;
const url = `https://${host}/dp/${String(asin).toUpperCase()}?psc=1`;
```

**域名映射**：

```7:7:backend/utils/spClient.js
const DOMAINS     = { US:'www.amazon.com', UK:'www.amazon.co.uk', DE:'www.amazon.de', FR:'www.amazon.fr', IT:'www.amazon.it', ES:'www.amazon.es' };
```

#### 2. 设置请求头

```javascript
headers: {
  'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125 Safari/537.36',
  'Accept-Language': 'en-US,en;q=0.9'
}
```

**目的**：

- 模拟浏览器请求，避免被反爬虫机制拦截
- 设置语言偏好

#### 3. 超时设置

```javascript
timeout: 15000;
```

**说明**：15 秒超时，避免长时间等待

#### 4. 多正则表达式匹配

系统使用 5 种不同的正则表达式来匹配父体 ASIN：

**模式 1**：`"parentAsin": "B08..."`（JSON 格式）

```javascript
data.match(/"parentAsin"\s*:\s*"([^"]+)"/i)?.[1];
```

**模式 2**：`"parent_asin": "B08..."`（下划线格式）

```javascript
data.match(/"parent_asin"\s*:\s*"([^"]+)"/i)?.[1];
```

**模式 3**：`data-asin-parent="B08..."`（HTML 属性）

```javascript
data.match(/data-asin-parent="([^"]+)"/i)?.[1];
```

**模式 4**：`"twisterJsInit": {... "parentAsin": "B08..."}`（JavaScript 对象）

```javascript
data.match(/"twisterJsInit".*?"parentAsin"\s*:\s*"([^"]+)"/i)?.[1];
```

**模式 5**：`"variationDisplayData": {... "parentAsin": "B08..."}`（变体显示数据）

```javascript
data.match(/"variationDisplayData".*?"parentAsin"\s*:\s*"([^"]+)"/i)?.[1];
```

**匹配策略**：

- 按顺序尝试每个正则表达式
- 使用空值合并操作符 `||` 连接
- 找到第一个匹配后停止

### 数据标准化

#### normalizeParent 函数

```9:16:backend/utils/spClient.js
function normalizeParent(parent, asin) {
  if (parent == null) return null;
  const p = String(parent).trim();
  if (!p) return null;
  const a = String(asin).trim();
  if (p.toUpperCase() === a.toUpperCase()) return null; // 父体=自身 → 置空
  return p;
}
```

**处理规则**：

1. 如果 `parent` 为 `null` 或 `undefined`，返回 `null`
2. 转换为字符串并去除空格
3. 如果为空字符串，返回 `null`
4. **关键**：如果父体 ASIN 等于自身 ASIN，返回 `null`（避免循环引用）

### HTML 抓取的局限性

#### 1. 成功率较低

- 依赖页面结构，可能因页面改版失效
- 成功率约 60%

#### 2. 性能开销

- 需要下载完整 HTML 页面
- 网络请求时间较长（最多 15 秒）

#### 3. 稳定性

- 可能被反爬虫机制拦截
- 页面结构变化会导致匹配失败

#### 4. 数据准确性

- 正则表达式匹配可能误匹配
- 需要额外的验证

## 错误处理最佳实践

### 1. 分层错误处理

**原则**：每层独立处理错误，不中断整体流程

```javascript
// 第一层
try {
  // SP-API调用
} catch (e) {
  console.error('第一层失败:', e);
  // 继续执行第二层
}

// 第二层
if (条件) {
  try {
    // Legacy调用
  } catch (e) {
    console.warn('第二层失败:', e);
    // 继续执行第三层
  }
}
```

### 2. 错误日志分级

- **console.error**：第一层失败（主要方式失败）
- **console.warn**：第二层失败（兜底方式失败）
- **静默处理**：第三层失败（最后兜底失败，不再记录）

### 3. 错误信息包含上下文

```javascript
console.error(`❌ 获取 ASIN ${asinNorm} @ ${marketKey} 失败:`, e?.message || e);
```

**包含信息**：

- ASIN 码
- 市场代码
- 错误消息

### 4. 优雅降级

系统设计允许部分功能失败：

- 如果获取不到父体 ASIN，仍可判断是否有变体（通过兄弟 ASIN）
- 如果获取不到品牌，使用"未知"作为默认值
- 如果所有方式都失败，返回 `hasVariation = false`（保守判断）

## 调试和监控

### 启用调试模式

设置环境变量 `SP_DEBUG=1` 启用详细日志：

```48:52:backend/utils/spapi.js
  if (process.env.SP_DEBUG === '1') {
    console.log(
      `初始化 SP-API 客户端: country=${country}, region=${region}, lib=amazon-sp-api, id=${(creds.clientId || '').slice(0, 18)}…`
    );
  }
```

**输出内容**：

- 客户端初始化信息
- API 调用失败详情
- 错误响应体

### 监控指标

建议监控以下指标：

1. **API 调用成功率**

   - 第一层成功率
   - 第二层成功率
   - 第三层成功率

2. **错误类型分布**

   - 400 错误数量
   - 403 错误数量
   - 404 错误数量
   - 429 错误数量
   - 500/503 错误数量

3. **兜底触发频率**

   - 第二层触发次数
   - 第三层触发次数

4. **响应时间**
   - 第一层平均响应时间
   - 第二层平均响应时间
   - 第三层平均响应时间

## 总结

三层兜底机制确保了系统的高可用性：

1. **第一层（SP-API）**：主要方式，成功率最高
2. **第二层（Legacy）**：第一层兜底，提供额外兼容性
3. **第三层（HTML）**：最后兜底，确保最大覆盖率

每层都有独立的错误处理，确保单层失败不影响整体流程。通过优雅降级和详细日志，系统能够在各种异常情况下保持稳定运行。
